package uid

import "time"

/**
 第1位bit：
 二进制中最高位为1的都是负数，但是我们所需要的id应该都是整数，所以这里最高位应该为0
 后面的41位bit：
 用来记录生成id时的毫秒时间戳，这里毫秒只用来表示正整数(计算机中正整数包含0)，
 所以可以表示的数值范围是0至2^41 - 1（这里为什么要-1很多人会范迷糊，要记住，计算机中数值都是从0开始计算而不是1）
 再后面的10位bit：
 用来记录工作机器的id
最后的12位：
用来表示单台机器每毫秒生成的id序号
12位bit可以表示的最大正整数为2^12 - 1 = 4096，即可用0、1、2、3...4095这4096(注意是从0开始计算)
个数字来表示1毫秒内机器生成的序号(这个算法限定单台机器1毫秒内最多生成4096个id，超出则等待下一毫秒再生成)
*/
/**
 * 1 符号位  |  39 时间戳                                     | 5 区域  |  9 节点       | 10 （毫秒内）自增ID
 * 0        |  0000000 00000000 00000000 00000000 00000000  | 00000  | 000000 000   |  000000 0000
 *
 */

const (
	nodeBits  uint8 = 10                    // 节点 ID 的位数
	stepBits  uint8 = 12                    // 序列号的位数
	nodeMax   int64 = -1 ^ (-1 << nodeBits) // 节点 ID 的最大值，用于检测溢出
	stepMax   int64 = -1 ^ (-1 << stepBits) // 序列号的最大值，用于检测溢出
	timeShift uint8 = nodeBits + stepBits   // 时间戳向左的偏移量
	nodeShift uint8 = stepBits              // 节点 ID 向左的偏移量
)

// 设置初始时间的时间戳 (毫秒表示)，我这里使用 twitter 设置的一个时间，这个可以随意设置 ，比现在的时间靠前即可。
var Epoch int64 = time.Now().UnixNano() / 1000000
